---
title: "analysis_cities"
author: "olaf könig"
format: html
editor: visual
---

# Loading data

```{r}

sf_municipalities <- read_sf("data_input/data_raw/sf_polg_swisstopo.gpkg")

df_cities_pop <- read_csv("data_input/data_raw/stats_cities.csv") %>% 
  select(bfs_nummer,nom_officiel, POP_2023)

list_cities_10 <- df_cities_pop %>% 
  slice_max(POP_2023, n=10) %>% 
  pull(bfs_nummer)

list_cities_6 <- df_cities_pop %>% 
  slice_max(POP_2023, n=6) %>% 
  pull(bfs_nummer)

sf_cities_10 <- sf_municipalities %>% 
  filter(bfs_nummer %in% list_cities_10)

sf_cities_6 <- sf_municipalities %>% 
  filter(bfs_nummer %in% list_cities_6)
```

```{r}

cities_translation <-tibble::tibble(
  bfs_nummer = c(261, 6621, 2701, 5586, 351, 230, 1061, 3203, 5192, 371),
  name_en = c(
    "Zurich",
    "Geneva",
    "Basel",
    "Lausanne",
    "Bern",
    "Winterthur",
    "Lucerne",
    "St. Gallen",
    "Lugano",
    "Biel/Bienne"
  )
)
```

```{r}

sf <- read_sf("data_input/data_edit/sep_cross_noise_no2_ndvi.gpkg") %>% select(ssep3:geom) %>% select(id, bfs_nummer, everything()) %>% 
  filter(bfs_nummer %in% list_cities_10) %>% 
  left_join(cities_translation)

# Invert the logic of NDVI indicator from more NDVI >= 0.5 to NDVI <= 0.5 (lack of green spaces)
sf <- sf %>%
  mutate(
    ndvi_200m = 1 - ndvi_200m,
    ndvi_500m = 1 - ndvi_500m
  )
```

# Edit data

Create a list of sf object for each cities

```{r}

list_sf_by_commune <- sf %>%
  left_join(cities_translation) %>% 
  filter(bfs_nummer %in% list_cities_10) %>%
  { split(., .$bfs_nummer) }
```

View list (optional)

```{r}
# library(listviewer)
# jsonedit(list_sf_by_commune)
```

## Reclassify ssep and classify for noise, no2 and ndvi

```{r}

library(dplyr)
library(purrr)

prepare_groupings <- function(df) {
  df %>%
    mutate(
      ssep3d_local_4  = ntile(ssep3, 4),
      ssep3d_local_5  = ntile(ssep3, 5),
      ssep3d_local_10 = ntile(ssep3, 10),
      noise_4  = ntile(noise, 4),
      noise_5  = ntile(noise, 5),
      noise_10 = ntile(noise, 10),
      no2_4    = ntile(no2, 4),
      no2_5    = ntile(no2, 5),
      no2_10   = ntile(no2, 10),
      ndvi_200m_4  = ntile(ndvi_200m, 4),
      ndvi_200m_5  = ntile(ndvi_200m, 5),
      ndvi_200m_10 = ntile(ndvi_200m, 10)
    )
}

list_sf_by_commune_grouped <- map(list_sf_by_commune, prepare_groupings)

```

## Compute agregated statistics for each quantiles

```{r}

summarise_by_grouping <- function(sf_commune, grouping_var) {
  sf_commune %>%
    st_drop_geometry() %>%
    group_by(bfs_nummer, .data[[grouping_var]]) %>%
    summarise(
      n = n(),
      pct_above_50_noise = mean(noise > 50) * 100,
      pct_above_60_noise = mean(noise > 60) * 100,
      pct_above_15_no2   = mean(no2 > 15) * 100,
      pct_above_20_no2   = mean(no2 > 20) * 100,
      pct_above_50_ndvi  = mean(ndvi_200m > 0.5) * 100,
      pct_above_60_ndvi  = mean(ndvi_200m > 0.6) * 100,
      .groups = "drop"
    )
}

# For quintiles
df_stats_quintiles <- map_dfr(
  list_sf_by_commune_grouped,
  summarise_by_grouping,
  grouping_var = "ssep3d_local_5"
)
# For quartiles
df_stats_quartiles <- map_dfr(
  list_sf_by_commune_grouped,
  summarise_by_grouping,
  grouping_var = "ssep3d_local_4"
)
# For deciles
df_stats_deciles <- map_dfr(
  list_sf_by_commune_grouped,
  summarise_by_grouping,
  grouping_var = "ssep3d_local_10"
)
```

### Merge the results into one df and transforme to long

```{r}

df_stats_deciles   <- mutate(df_stats_deciles,   quantile_type = "Déciles")
df_stats_quintiles <- mutate(df_stats_quintiles, quantile_type = "Quintiles")
df_stats_quartiles <- mutate(df_stats_quartiles, quantile_type = "Quartiles")

df_stats_deciles <- df_stats_deciles %>%
  rename(group = ssep3d_local_10) %>%
  select(
    bfs_nummer,
    group,
    quantile_type,
    matches("^pct_above") # plus besoin de ^pct_below
  )

df_stats_quintiles <- df_stats_quintiles %>%
  rename(group = ssep3d_local_5) %>%
  select(
    bfs_nummer,
    group,
    quantile_type,
    matches("^pct_above")
  )

df_stats_quartiles <- df_stats_quartiles %>%
  rename(group = ssep3d_local_4) %>%
  select(
    bfs_nummer,
    group,
    quantile_type,
    matches("^pct_above")
  )

df_stats_all <- bind_rows(df_stats_deciles, df_stats_quintiles, df_stats_quartiles)

df_stats_long <- df_stats_all %>%
  pivot_longer(
    cols = matches("^pct_above"),
    names_to = "indicator",
    values_to = "value"
  ) %>%
  mutate(
    indicator_label = recode(indicator,
      "pct_above_50_noise" = "Bruit > 50 dB",
      "pct_above_60_noise" = "Bruit > 60 dB",
      "pct_above_15_no2"  = "NO2 > 15",
      "pct_above_20_no2"  = "NO2 > 20",
      "pct_above_50_ndvi" = "Limited green access (NDVI < 0.5)",
      "pct_above_60_ndvi" = "Limited green access (NDVI < 0.6)"
    )
  ) %>% 
  left_join(cities_translation)

df_stats_long <- df_stats_long %>%
  mutate(
    indicator_family = case_when(
      grepl("noise", indicator) ~ "Bruit",
      grepl("no2", indicator) ~ "NO2",
      grepl("ndvi", indicator) ~ "NDVI"
    )
  )

```

Colors

```{r}

df_stats_long <- df_stats_long %>%
  mutate(
    indicator_label = recode(indicator,
      "pct_above_50_noise" = "Exposed to noise >50 dB",
      "pct_above_60_noise" = "Exposed to noise >60 dB",
      "pct_above_15_no2"   = "Exposed to NO₂ >15 μg/m³",
      "pct_above_20_no2"   = "Exposed to NO₂ >20 μg/m³",
      "pct_above_50_ndvi"  = "Limited green access (NDVI < 0.5)",
      "pct_above_60_ndvi"  = "Limited green access (NDVI < 0.6)"
    )
  )
```

## Visualise

```{r}

df_minimal <- df_stats_long %>%
  filter(
    indicator_label %in% c(
      "Exposed to noise >50 dB",
      "Exposed to NO₂ >20 μg/m³",
      "Limited green access (NDVI < 0.5)"
    )
  )
table(df_minimal$indicator_label)

```

## Batch chart svg export

```{r}

output_dir <- "data_output/city_charts_minimal_svg/"
dir_create(output_dir)

unique_codes <- unique(df_minimal$bfs_nummer)

plot_city <- function(city_code) {
  df_city <- df_minimal %>% filter(bfs_nummer == city_code)
  ggplot(
    df_city,
    aes(
      y = factor(group),
      x = value,
      fill = indicator_label
    )
  ) +
    geom_col(
      width = 0.7,
      position = position_dodge(width = 0.8)
    ) +
    geom_text(
      aes(label = sprintf("%.1f", value), colour = indicator_label),
      position = position_dodge(width = 0.8),
      hjust = -0.15,
      size = 3.2,
      family = "IBM Plex Sans"
    ) +
    scale_fill_manual(
      values = c(
        "Exposed to noise >50 dB"           = "#FC9272",  # orange
        "Exposed to NO₂ >20 μg/m³"          = "#4882A1",  # bleu
        "Limited green access (NDVI < 0.5)" = "#A1D99B"   # vert
      )
    ) +
    scale_colour_manual(
      values = c(
        "Exposed to noise >50 dB"           = "#FC9272",
        "Exposed to NO₂ >20 μg/m³"          = "#4882A1",
        "Limited green access (NDVI < 0.5)" = "#A1D99B"
      )
    ) +
    facet_grid(quantile_type ~ indicator_family, switch = "y") +
    labs(
      title = paste("Environmental exposures –", unique(df_city$name_en)),
      y = "Group (local SES quartile/quintile/decile)",
      x = "Share of exposed households (%)",
      fill = NULL
    ) +
    theme_minimal(base_family = "IBM Plex Sans") +
    theme(
      strip.text = element_text(face = "bold"),
      axis.title.y = element_text(face = "bold"),
      axis.title.x = element_text(face = "bold"),
      legend.position = "bottom"
    ) +
    coord_cartesian(xlim = c(0, max(df_city$value, na.rm = TRUE) * 1.15))
}

walk(unique_codes, ~{
  g <- plot_city(.x)
  ggsave(
    filename = path(output_dir, paste0("city_", .x, ".svg")),
    plot = g,
    width = 8, height = 5
  )
  invisible(NULL)
})

```

## DW lollipop chart to show disparities within the cities

<https://app.datawrapper.de/edit/iLHkd/visualize#refine>

```{r}
dw_cities_lolipop <- df_stats_long %>% 
  filter(
    quantile_type == "Quartiles",
    group %in% c(1, 4),
    indicator_label %in% c(
      "Exposed to noise >50 dB",
      "Exposed to NO₂ >15 μg/m³",
      "Limited green access (NDVI < 0.5)"
    )
  ) %>% 
  select(bfs_nummer, name_en, group, indicator_label, value) %>% 
  mutate(
    indicator_label_en = case_when(
      indicator_label == "Exposed to noise >50 dB" ~ "Households exposed to noise >50 dB",
      indicator_label == "Exposed to NO₂ >15 μg/m³" ~ "Households exposed to NO₂ >15 μg/m³",
      indicator_label == "Limited green access (NDVI < 0.5)" ~ 'Households with limited green access: less than 50% of "green" surfaces within 200m'
    )
  ) %>% 
  pivot_wider(
    names_from = "group",
    values_from = "value"
  ) %>% 
  rename(
    "Lowest SES" = `1`,
    "Highest SES" = `4`
  )

```

```{r}

dw_cities_lolipop %>% 
  dw_data_to_chart("iLHkd")
```

# Scatterplot charts

### Classification in quartles (string)

```{r}

sf_grouped <- bind_rows(list_sf_by_commune_grouped)

sf_grouped <- sf_grouped %>%
  mutate(
    # Paires SES avec chaque variable
    ssep_noise_pair = paste0("SES", ssep3d_local_4, "-Noise", noise_4),
    ssep_no2_pair   = paste0("SES", ssep3d_local_4, "-NO2", no2_4),
    ssep_ndvi_pair  = paste0("SES", ssep3d_local_4, "-Green", ndvi_200m_4),
    
    # Labels explicites avec inversion corrigée : 1 = Low SES, 4 = High SES
    ssep_noise_label = case_when(
      ssep3d_local_4 == 1 & noise_4 == 4 ~ "Low SES / High Noise",
      ssep3d_local_4 == 1 & noise_4 == 1 ~ "Low SES / Low Noise",
      ssep3d_local_4 == 4 & noise_4 == 4 ~ "High SES / High Noise",
      ssep3d_local_4 == 4 & noise_4 == 1 ~ "High SES / Low Noise",
      TRUE ~ "Other combination"
    ),
    ssep_no2_label = case_when(
      ssep3d_local_4 == 1 & no2_4 == 4 ~ "Low SES / High NO₂",
      ssep3d_local_4 == 1 & no2_4 == 1 ~ "Low SES / Low NO₂",
      ssep3d_local_4 == 4 & no2_4 == 4 ~ "High SES / High NO₂",
      ssep3d_local_4 == 4 & no2_4 == 1 ~ "High SES / Low NO₂",
      TRUE ~ "Other combination"
    ),
    ssep_ndvi_label = case_when(
      ssep3d_local_4 == 1 & ndvi_200m_4 == 4 ~ "Low SES / Low Green",
      ssep3d_local_4 == 1 & ndvi_200m_4 == 1 ~ "Low SES / High Green",
      ssep3d_local_4 == 4 & ndvi_200m_4 == 4 ~ "High SES / Low Green",
      ssep3d_local_4 == 4 & ndvi_200m_4 == 1 ~ "High SES / High Green",
      TRUE ~ "Other combination"
    ),
    # Combinaison globale (corrigée)
    ssep_global_label = paste0(
      ifelse(ssep3d_local_4 == 1, "Low SES", ifelse(ssep3d_local_4 == 4, "High SES", "Mid SES")), " / ",
      ifelse(no2_4 == 1, "Low NO₂", ifelse(no2_4 == 4, "High NO₂", "Mid NO₂")), " / ",
      ifelse(noise_4 == 1, "Low Noise", ifelse(noise_4 == 4, "High Noise", "Mid Noise")), " / ",
      ifelse(ndvi_200m_4 == 1, "Low Green", ifelse(ndvi_200m_4 == 4, "High Green", "Mid Green"))
    )
  )

```

### Export

```{r}

# sf_grouped %>% 
#   write_sf("data_input/data_edit/cities_reclassified.gpkg")
```

## Making scatterplot template

#### Helper: descritptive statistics to adjust axes

```{r}

desc_stats <- function(x, na.rm = TRUE) {
  data.frame(
    min = min(x, na.rm = na.rm),
    q10 = quantile(x, 0.1, na.rm = na.rm),
    q25 = quantile(x, 0.25, na.rm = na.rm),
    median = quantile(x, 0.5, na.rm = na.rm),
    q75 = quantile(x, 0.75, na.rm = na.rm),
    q90 = quantile(x, 0.9, na.rm = na.rm),
    max = max(x, na.rm = na.rm)
  )
}

# desc_stats(sf_grouped$ndvi_200m)
# desc_stats(sf_grouped$no2)
# desc_stats(sf_grouped$noise)
```

### Template noise

<https://app.datawrapper.de/edit/fTu0m/upload>

```{r}

sf_grouped %>% 
  st_drop_geometry() %>% 
  filter(bfs_nummer == 230) %>% 
  select(ssep3, noise, ssep_noise_label) %>% 
  dw_data_to_chart("fTu0m")
```

### Template NO2

<https://app.datawrapper.de/edit/i3eIP/visualize#annotate>

```{r}

sf_grouped %>% 
  st_drop_geometry() %>% 
  filter(bfs_nummer == 230) %>% 
  select(ssep3, no2, ssep_no2_label) %>% 
  dw_data_to_chart("i3eIP")
```

### Template Green

<https://app.datawrapper.de/edit/yVzPw/visualize#annotate>

```{r}

sf_grouped %>% 
  st_drop_geometry() %>% 
  filter(bfs_nummer == 230) %>% 
  select(ssep3, ndvi_200m, ssep_ndvi_label) %>%
  mutate(ndvi_200m = ndvi_200m * 100) %>% 
  dw_data_to_chart("yVzPw")
```

## DW Scatterplot batch production

```{r}

library(dplyr)
library(purrr)
library(DatawRappr)

dw_batch_charts_by_indicator <- function(
  df,
  bfs_list,
  template_ids = list(
    noise = "fTu0m",
    no2   = "i3eIP",
    green = "yVzPw"
  ),
  folder_ids = list(
    noise = "335712",
    no2   = "335711",
    green = "335713"
  ),
  output_chart_infos = "chart_ids.RData"
) {
  indicator_vars <- list(
    noise = list(var = "noise", label = "ssep_noise_label"),
    no2   = list(var = "no2", label = "ssep_no2_label"),
    green = list(var = "ndvi_200m", label = "ssep_ndvi_label")
  )
  
  create_city_chart <- function(city_id, indicator) {
    var_info <- indicator_vars[[indicator]]
    template_id <- template_ids[[indicator]]
    folder_id <- folder_ids[[indicator]]
    
    df_city <- df %>%
      filter(bfs_nummer == city_id) %>%
      st_drop_geometry()
    city_name <- unique(df_city$name_en)
    city_name <- paste0('<span style="font-size: 0.8em;">', city_name, '</span>')
    if(length(city_name) != 1) city_name <- as.character(city_id)
    
    new_chart <- dw_copy_chart(template_id)
    new_chart_id <- new_chart[["id"]]
    
    dw_edit_chart(
      chart_id = new_chart_id,
      title = city_name,
      folderId = folder_id
    )
    
    data_to_send <- df_city %>%
      select(
        ssep3,
        value = all_of(var_info$var),
        indicator_label = all_of(var_info$label)
      )
    if (indicator == "green") {
      data_to_send <- data_to_send %>% mutate(value = value * 100)
    }
    
    dw_data_to_chart(
      data_to_send,
      chart_id = new_chart_id
    )
    
    published_chart <- dw_publish_chart(new_chart_id, return_object = TRUE)
    
    tibble(
      city_id = city_id,
      city_name = city_name,
      indicator = indicator,
      url = published_chart$publicUrl,
      iframe = published_chart$iframeCode,
      chart_id = new_chart_id
    )
  }
  
  chart_infos <- purrr::cross_df(list(
    city_id = bfs_list,
    indicator = names(template_ids)
  )) %>%
    pmap_dfr(~create_city_chart(..1, ..2))
  
  saveRDS(chart_infos, output_chart_infos)
  chart_infos
}

```

```{r}

bfs_list <- sf_grouped %>% 
  st_drop_geometry() %>% 
  pull(bfs_nummer) %>% 
  unique()

chart_results <- dw_batch_charts_by_indicator(
  df = sf_grouped,
  bfs_list = bfs_list,
  output_chart_infos = "data_output/scatterplot_chart_ids.RData"
)

```

```{r}

# chart_results %>% filter(city_id %in% list_cities_6) %>% select(city_id, iframe) %>% clipr::write_clip()
```

### HTML Small multiple panel creation

```{r}

library(tidyr)
library(dplyr)
library(glue)

chart_results_wide <- chart_results %>%
  select(city_name, indicator, iframe) %>%
  pivot_wider(names_from = indicator, values_from = iframe)

html_blocks <- chart_results_wide %>%
  mutate(
    html = glue::glue(
      '
<div class="city-grid">
  <div class="city-title">{city_name}</div>
  <div>
    <div class="indicator-label">Noise</div>
    {noise}
  </div>
  <div>
    <div class="indicator-label">NO₂</div>
    {no2}
  </div>
  <div>
    <div class="indicator-label">Green</div>
    {green}
  </div>
</div>
      '
    )
  ) %>% pull(html)

cat(paste(html_blocks, collapse = "\n\n"))


```

# Cartography cities (6 cities)

```{r}

sf_for_maps <- sf_grouped %>% 
  filter(bfs_nummer %in% list_cities_6) %>% 
  select(name_en, ssep_noise_label, ssep_no2_label, ssep_ndvi_label, ssep_global_label)
```

### Colors

```{r}

get_cat_color <- function(label, rouge, orange) {
  case_when(
    label == rouge  ~ "#E74C3C",  # Rouge
    label == orange ~ "#FFA500",  # Orange
    TRUE            ~ "#D3D3D3"   # Gris
  )
}

sf_for_maps <- sf_grouped %>%
  select(name_en, ssep_noise_label, ssep_no2_label, ssep_ndvi_label, ssep_global_label) %>%
  mutate(
    color_noise = get_cat_color(ssep_noise_label,  "Low SES / High Noise",  "High SES / Low Noise"),
    color_no2   = get_cat_color(ssep_no2_label,    "Low SES / High NO₂",    "High SES / Low NO₂"),
    color_ndvi  = get_cat_color(ssep_ndvi_label,   "Low SES / Low Green",   "High SES / High Green")
  )

```

### Transform data to facetting

```{r}

library(tidyr)
sf_for_maps_long <- sf_for_maps %>%
  pivot_longer(
    cols = starts_with("ssep_"),
    names_to = "indicator",
    values_to = "label"
  ) %>%
  pivot_longer(
    cols = starts_with("color_"),
    names_to = "indicator_color",
    values_to = "color"
  ) %>%
  # On garde les bonnes paires label/couleur/indicateur
  filter(
    case_when(
      indicator == "ssep_noise_label"  & indicator_color == "color_noise"  ~ TRUE,
      indicator == "ssep_no2_label"    & indicator_color == "color_no2"    ~ TRUE,
      indicator == "ssep_ndvi_label"   & indicator_color == "color_ndvi"   ~ TRUE,
      TRUE ~ FALSE
    )
  ) %>%
  mutate(
    indicator = recode(indicator,
      "ssep_noise_label" = "Noise",
      "ssep_no2_label" = "NO₂",
      "ssep_ndvi_label" = "Green"
    )
  )

```

### Test map for Lausanne

```{r}
tmap_mode(mode = "view")
tm_shape(sf_for_maps_long %>% filter(name_en == "Lausanne")) +
  tm_dots(fill = "color", size = 0.4, fill.legend = tm_legend_hide()) +
  tm_facets_grid(rows = "indicator") +
  tm_title("Lausanne – Extreme SES / Exposure by Indicator")

```

### Maps for 6 cities

```{r}

list_6_cities_en_names <- unique(sf_for_maps_long$name_en)

plots <- purrr::map(
  list_6_cities_en_names,
  ~ tm_shape(sf_for_maps_long %>% filter(name_en == .x)) +
      tm_dots(fill = "color", size = 0.3, fill.legend = tm_legend_hide()) +
      tm_facets_grid(rows = "indicator") +
      tm_title(.x)
)

```

### Plot one map

```{r}
plots[[5]]   # Affiche la 1ère ville

```

### Save tmaps facets into (fucking useless) PNG

```{r}

purrr::walk2(
  plots,
  list_6_cities_en_names,
  ~ tmap_save(.x, paste0("data_output/tmaps/tmap_", .y, ".png"), width = 4000, height = 4000)
)


```

# Cartographic generalisation test

### Split sf

```{r}

library(purrr)

# Liste des villes
list_cities <- unique(sf_for_maps_long$name_en)

# Créer une liste de points par ville
list_pts_by_city <- purrr::map(
  list_cities,
  ~ sf_for_maps_long %>% filter(name_en == .x)
)
names(list_pts_by_city) <- list_cities

```

### KDE + contours pour chaque ville

```{r}
library(sf)
library(spatstat.geom)
library(spatstat.explore)
library(stars)
library(abind)

get_density_polygons <- function(pts_sf, sigma = 200, quantile_cut = 0.8) {
  coords <- st_coordinates(pts_sf)
  w <- as.owin(st_bbox(pts_sf))
  ppp_pts <- as.ppp(coords, W = w)
  dens <- spatstat.explore::density.ppp(ppp_pts, sigma = sigma)
  ras <- raster::raster(dens)
  stars_ras <- st_as_stars(ras)
  # Correction ici :
  vals <- as.vector(stars_ras[[1]])
  iso <- st_contour(stars_ras, breaks = quantile(vals, probs = quantile_cut, na.rm = TRUE))
  iso$city <- unique(pts_sf$name_en)
  iso
}


```

### Appel sur toutes les villes

```{r}

list_6_cities_en_names <- unique(sf_for_maps_long$name_en)

list_isopolys <- purrr::map(
  list_6_cities_en_names,
  ~ get_density_polygons(
      sf_for_maps_long %>% filter(name_en == .x),
      sigma = 200, quantile_cut = 0.8
    )
)

```

### Fusionne les polygones

```{r}

library(dplyr)
isopolys <- bind_rows(list_isopolys)

```

## TEST pour les extrêmes

### Filtrer les points extrêmes par ville et indicateur

```{r}

library(dplyr)
library(purrr)

# Indique le mapping label <-> indicateur (modifie selon ta convention NDVI/Green)
keep_labels <- list(
  noise = c("Low SES / High Noise", "High SES / Low Noise"),
  no2   = c("Low SES / High NO₂", "High SES / Low NO₂"),
  ndvi  = c("Low SES / Low Green", "High SES / High Green")
)

```

### Filtrer et générer les hotspots pour chaque indicateur

```{r}
# NO2
list_isopolys_no2 <- purrr::map(
  list_6_cities_en_names,
  ~ get_density_polygons(
      sf_for_maps_long %>% 
        filter(
          name_en == .x,
          indicator == "NO₂",
          label %in% keep_labels$no2
        ),
      sigma = 200, quantile_cut = 0.8
    )
)
isopolys_no2 <- bind_rows(list_isopolys_no2)

# NOISE
list_isopolys_noise <- purrr::map(
  list_6_cities_en_names,
  ~ get_density_polygons(
      sf_for_maps_long %>% 
        filter(
          name_en == .x,
          indicator == "Noise",
          label %in% keep_labels$noise
        ),
      sigma = 200, quantile_cut = 0.8
    )
)
isopolys_noise <- bind_rows(list_isopolys_noise)

# NDVI
list_isopolys_ndvi <- purrr::map(
  list_6_cities_en_names,
  ~ get_density_polygons(
      sf_for_maps_long %>% 
        filter(
          name_en == .x,
          indicator == "Green",
          label %in% keep_labels$ndvi
        ),
      sigma = 200, quantile_cut = 0.8
    )
)
isopolys_ndvi <- bind_rows(list_isopolys_ndvi)


```

```{r}

isopolys_all <- bind_rows(
  isopolys_noise %>% mutate(indicator = "Noise"),
  isopolys_no2   %>% mutate(indicator = "NO₂"),
  isopolys_ndvi  %>% mutate(indicator = "Green")
)

```

```{r}

sf_points_extreme <- sf_for_maps_long %>%
  filter(
    (indicator == "NO₂"   & label %in% keep_labels$no2) |
    (indicator == "Noise" & label %in% keep_labels$noise) |
    (indicator == "Green" & label %in% keep_labels$ndvi)
  ) %>%
  mutate(city = name_en)  # harmonise avec isopolys_all


tm_shape(isopolys_all) +
  tm_polygons(fill = "indicator", fill_alpha = 0.5) +
tm_shape(sf_points_extreme) +
  tm_dots(fill = "color", size = 0.08, fill.legend = tm_legend_hide()) +
  tm_facets_grid(rows = "city", columns = "indicator") +
  tm_title("Hotspots: Extreme SES / Exposure by City and Indicator")

```

```{r}
sf::st_write(isopolys_all, "data_output/hotspots_extreme_ses_exposure.gpkg", layer = "hotspots", delete_layer = TRUE)

```

# Heatmaps with Claude

```{r}

create_hotspots_by_category <- function(sf_data, 
                                       target_indicator = "Green",
                                       sigma = 50,
                                       quantile_cut = 0.85,
                                       min_points = 8) {
  
  # Définir les catégories d'intérêt
  if (target_indicator == "Green") {
    wealthy_healthy <- "High SES / High Green"
    poor_unhealthy <- "Low SES / Low Green"
  } else if (target_indicator == "Noise") {
    wealthy_healthy <- "High SES / Low Noise"
    poor_unhealthy <- "Low SES / High Noise"
  }
  
  # Filtrer les données pour l'indicateur
  sf_filtered <- sf_data %>%
    filter(indicator == target_indicator,
           label %in% c(wealthy_healthy, poor_unhealthy))
  
  cities <- unique(sf_filtered$name_en)
  
  # Fonction pour créer des polygones propres
  create_clean_polygons <- function(points_sf, category_name) {
    if (nrow(points_sf) < min_points) return(NULL)
    
    # Sauvegarder le CRS original
    original_crs <- st_crs(points_sf)
    
    # Projeter en LV95 pour les calculs
    if (st_is_longlat(points_sf)) {
      points_projected <- st_transform(points_sf, 2056)
    } else {
      points_projected <- points_sf
    }
    
    coords <- st_coordinates(points_projected)
    
    # Créer une fenêtre plus serrée autour des points
    bbox <- st_bbox(points_projected)
    margin <- sigma * 2  # Réduire la marge
    
    w <- owin(xrange = c(bbox$xmin - margin, bbox$xmax + margin),
              yrange = c(bbox$ymin - margin, bbox$ymax + margin))
    
    ppp_pts <- ppp(x = coords[,1], y = coords[,2], window = w)
    dens <- density.ppp(ppp_pts, sigma = sigma, edge = TRUE)
    
    # Convertir en stars avec CRS
    ras <- raster::raster(dens)
    raster::crs(ras) <- sp::CRS("+init=epsg:2056")  # Forcer le CRS
    stars_ras <- st_as_stars(ras)
    
    vals <- as.vector(stars_ras[[1]])
    vals_clean <- vals[!is.na(vals) & vals > 0]
    
    if (length(vals_clean) == 0) return(NULL)
    
    threshold <- quantile(vals_clean, probs = quantile_cut, na.rm = TRUE)
    
    # Créer contours
    contours <- st_contour(stars_ras, breaks = threshold)
    
    if (nrow(contours) == 0) return(NULL)
    
    # SOLUTION : Créer un masque avec les points pour découper
    points_buffer <- st_buffer(points_projected, dist = sigma * 1.5)
    points_union <- st_union(points_buffer)
    
    # Traitement des polygones
    polygons <- contours %>%
      filter(Max == Inf | Max > threshold) %>%
      st_cast("POLYGON") %>%
      st_buffer(0) %>%
      st_intersection(points_union) %>%  # DÉCOUPER avec le masque des points
      st_simplify(dTolerance = 10) %>%
      mutate(area_m2 = as.numeric(st_area(.))) %>%
      filter(area_m2 > 1000) %>%
      select(-any_of(c("layer", "Min", "Max"))) %>%
      mutate(
        city = unique(points_sf$name_en)[1],
        category = category_name,
        indicator = target_indicator,
        n_source_points = nrow(points_sf)
      )
    
    # Retransformer dans le CRS original
    if (!is.na(original_crs)) {
      polygons <- st_transform(polygons, original_crs)
    }
    
    return(polygons)
  }
  
  # Traiter chaque ville et chaque catégorie
  results <- map_dfr(cities, function(city) {
    city_data <- sf_filtered %>% filter(name_en == city)
    
    wealthy_points <- city_data %>% filter(label == wealthy_healthy)
    poor_points <- city_data %>% filter(label == poor_unhealthy)
    
    wealthy_polygons <- create_clean_polygons(wealthy_points, "wealthy_healthy")
    poor_polygons <- create_clean_polygons(poor_points, "poor_unhealthy")
    
    bind_rows(wealthy_polygons, poor_polygons)
  })
  
  return(results)
}
```

### Function call for NDVI

```{r}

# Vérifier le CRS de tes données originales
st_crs(sf_for_maps_long)

# Relancer
hotspots_clean <- create_hotspots_by_category(
  sf_for_maps_long,
  target_indicator = "Green",
  sigma = 50,
  quantile_cut = 0.9,
  min_points = 10
)

# Vérifier le CRS du résultat
st_crs(hotspots_clean)

# Test mapview
mapview(hotspots_clean[hotspots_clean$city == "Geneva",], zcol = "category")
```

### GPKG Export

```{r}

# S'assurer qu'on exporte le bon objet
st_write(hotspots_clean, 
         "data_output/hotspots_GREEN_ONLY_clean.gpkg", 
         delete_dsn = TRUE)

# Vérification avant export
cat("Colonnes dans hotspots_clean:", names(hotspots_clean), "\n")
cat("Indicateurs:", unique(hotspots_clean$indicator), "\n")
cat("Catégories:", unique(hotspots_clean$category), "\n")
```

### NO2 and Noise

```{r}

create_hotspots_by_category <- function(sf_data, 
                                       target_indicator = "Green",
                                       sigma = 50,
                                       quantile_cut = 0.85,
                                       min_points = 8) {
  
  # Définir les catégories d'intérêt (avec le bon nom pour NO2)
  if (target_indicator == "Green") {
    wealthy_healthy <- "High SES / High Green"
    poor_unhealthy <- "Low SES / Low Green"
  } else if (target_indicator == "Noise") {
    wealthy_healthy <- "High SES / Low Noise"
    poor_unhealthy <- "Low SES / High Noise"
  } else if (target_indicator == "NO₂") {  # Avec le caractère spécial
    wealthy_healthy <- "High SES / Low NO₂"
    poor_unhealthy <- "Low SES / High NO₂"
  } else {
    stop("Indicateur non reconnu. Utiliser 'Green', 'Noise', ou 'NO₂'")
  }
  
  # Le reste de la fonction reste identique...
  sf_filtered <- sf_data %>%
    filter(indicator == target_indicator,
           label %in% c(wealthy_healthy, poor_unhealthy))
  
  cities <- unique(sf_filtered$name_en)
  
  create_clean_polygons <- function(points_sf, category_name) {
    if (nrow(points_sf) < min_points) return(NULL)
    
    original_crs <- st_crs(points_sf)
    
    if (st_is_longlat(points_sf)) {
      points_projected <- st_transform(points_sf, 2056)
    } else {
      points_projected <- points_sf
    }
    
    coords <- st_coordinates(points_projected)
    bbox <- st_bbox(points_projected)
    margin <- sigma * 2
    
    w <- owin(xrange = c(bbox$xmin - margin, bbox$xmax + margin),
              yrange = c(bbox$ymin - margin, bbox$ymax + margin))
    
    ppp_pts <- ppp(x = coords[,1], y = coords[,2], window = w)
    dens <- density.ppp(ppp_pts, sigma = sigma, edge = TRUE)
    
    ras <- raster::raster(dens)
    raster::crs(ras) <- sp::CRS("+init=epsg:2056")
    stars_ras <- st_as_stars(ras)
    
    vals <- as.vector(stars_ras[[1]])
    vals_clean <- vals[!is.na(vals) & vals > 0]
    
    if (length(vals_clean) == 0) return(NULL)
    
    threshold <- quantile(vals_clean, probs = quantile_cut, na.rm = TRUE)
    contours <- st_contour(stars_ras, breaks = threshold)
    
    if (nrow(contours) == 0) return(NULL)
    
    points_buffer <- st_buffer(points_projected, dist = sigma * 1.5)
    points_union <- st_union(points_buffer)
    
    polygons <- contours %>%
      filter(Max == Inf | Max > threshold) %>%
      st_cast("POLYGON") %>%
      st_buffer(0) %>%
      st_intersection(points_union) %>%
      st_simplify(dTolerance = 10) %>%
      mutate(area_m2 = as.numeric(st_area(.))) %>%
      filter(area_m2 > 1000) %>%
      select(-any_of(c("layer", "Min", "Max"))) %>%
      mutate(
        city = unique(points_sf$name_en)[1],
        category = category_name,
        indicator = target_indicator,
        n_source_points = nrow(points_sf)
      )
    
    if (!is.na(original_crs)) {
      polygons <- st_transform(polygons, original_crs)
    }
    
    return(polygons)
  }
  
  results <- map_dfr(cities, function(city) {
    city_data <- sf_filtered %>% filter(name_en == city)
    
    wealthy_points <- city_data %>% filter(label == wealthy_healthy)
    poor_points <- city_data %>% filter(label == poor_unhealthy)
    
    wealthy_polygons <- create_clean_polygons(wealthy_points, "wealthy_healthy")
    poor_polygons <- create_clean_polygons(poor_points, "poor_unhealthy")
    
    bind_rows(wealthy_polygons, poor_polygons)
  })
  
  return(results)
}
```
