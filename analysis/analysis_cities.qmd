---
title: "analysis_cities"
author: "olaf könig"
format: html
editor: visual
---

# Loading data

```{r}

sf_municipalities <- read_sf("data_input/data_raw/sf_polg_swisstopo.gpkg")

df_cities_pop <- read_csv("data_input/data_raw/stats_cities.csv") %>% 
  select(bfs_nummer,nom_officiel, POP_2023)

list_cities_10 <- df_cities_pop %>% 
  slice_max(POP_2023, n=10) %>% 
  pull(bfs_nummer)

list_cities_6 <- df_cities_pop %>% 
  slice_max(POP_2023, n=6) %>% 
  pull(bfs_nummer)

sf_cities_10 <- sf_municipalities %>% 
  filter(bfs_nummer %in% list_cities_10)

sf_cities_6 <- sf_municipalities %>% 
  filter(bfs_nummer %in% list_cities_6)
```

```{r}

cities_translation <-tibble::tibble(
  bfs_nummer = c(261, 6621, 2701, 5586, 351, 230, 1061, 3203, 5192, 371),
  name_en = c(
    "Zurich",
    "Geneva",
    "Basel",
    "Lausanne",
    "Bern",
    "Winterthur",
    "Lucerne",
    "St. Gallen",
    "Lugano",
    "Biel/Bienne"
  )
)
```

```{r}

sf <- read_sf("data_input/data_edit/sep_cross_noise_no2_ndvi.gpkg") %>% 
  select(ssep3:geom) %>% 
  select(id, bfs_nummer, everything()) %>% 
  filter(bfs_nummer %in% list_cities_10) %>% 
  left_join(cities_translation)

# Invert the logic of NDVI indicator from more NDVI >= 0.5 to NDVI <= 0.5 (lack of green spaces)
sf <- sf %>%
  mutate(
    ndvi_200m = 1 - ndvi_200m,
    ndvi_500m = 1 - ndvi_500m
  )

sf_national <- read_sf("data_input/data_edit/sep_cross_noise_no2_ndvi.gpkg") %>% 
  select(ssep3:geom) %>%
  select(id, bfs_nummer, everything()) 
```

# Edit data

Create a list of sf object for each cities

```{r}

list_sf_by_commune <- sf %>%
  left_join(cities_translation) %>% 
  filter(bfs_nummer %in% list_cities_10) %>%
  { split(., .$bfs_nummer) }
```

View list (optional)

```{r}
# library(listviewer)
# jsonedit(list_sf_by_commune)
```

## Reclassify ssep and classify for noise, no2 and ndvi

```{r}

library(dplyr)
library(purrr)

prepare_groupings <- function(df) {
  df %>%
    mutate(
      ssep3d_local_4  = ntile(ssep3, 4),
      ssep3d_local_5  = ntile(ssep3, 5),
      ssep3d_local_10 = ntile(ssep3, 10),
      noise_4  = ntile(noise, 4),
      noise_5  = ntile(noise, 5),
      noise_10 = ntile(noise, 10),
      no2_4    = ntile(no2, 4),
      no2_5    = ntile(no2, 5),
      no2_10   = ntile(no2, 10),
      ndvi_200m_4  = ntile(ndvi_200m, 4),
      ndvi_200m_5  = ntile(ndvi_200m, 5),
      ndvi_200m_10 = ntile(ndvi_200m, 10)
    )
}

list_sf_by_commune_grouped <- map(list_sf_by_commune, prepare_groupings)
```

## Compute agregated statistics for each quantiles

```{r}

summarise_by_grouping <- function(sf_commune, grouping_var) {
  sf_commune %>%
    st_drop_geometry() %>%
    group_by(bfs_nummer, .data[[grouping_var]]) %>%
    summarise(
      n = n(),
      pct_above_50_noise = mean(noise > 50) * 100,
      pct_above_60_noise = mean(noise > 60) * 100,
      pct_above_15_no2   = mean(no2 > 15) * 100,
      pct_above_20_no2   = mean(no2 > 20) * 100,
      pct_above_50_ndvi  = mean(ndvi_200m > 0.5) * 100,
      pct_above_60_ndvi  = mean(ndvi_200m > 0.6) * 100,
      .groups = "drop"
    )
}

# For quintiles
df_stats_quintiles <- map_dfr(
  list_sf_by_commune_grouped,
  summarise_by_grouping,
  grouping_var = "ssep3d_local_5"
)
# For quartiles
df_stats_quartiles <- map_dfr(
  list_sf_by_commune_grouped,
  summarise_by_grouping,
  grouping_var = "ssep3d_local_4"
)
# For deciles
df_stats_deciles <- map_dfr(
  list_sf_by_commune_grouped,
  summarise_by_grouping,
  grouping_var = "ssep3d_local_10"
)
```

### Merge the results into one df and transforme to long

```{r}

df_stats_deciles   <- mutate(df_stats_deciles,   quantile_type = "Déciles")
df_stats_quintiles <- mutate(df_stats_quintiles, quantile_type = "Quintiles")
df_stats_quartiles <- mutate(df_stats_quartiles, quantile_type = "Quartiles")

df_stats_deciles <- df_stats_deciles %>%
  rename(group = ssep3d_local_10) %>%
  select(
    bfs_nummer,
    group,
    quantile_type,
    matches("^pct_above") # plus besoin de ^pct_below
  )

df_stats_quintiles <- df_stats_quintiles %>%
  rename(group = ssep3d_local_5) %>%
  select(
    bfs_nummer,
    group,
    quantile_type,
    matches("^pct_above")
  )

df_stats_quartiles <- df_stats_quartiles %>%
  rename(group = ssep3d_local_4) %>%
  select(
    bfs_nummer,
    group,
    quantile_type,
    matches("^pct_above")
  )

df_stats_all <- bind_rows(df_stats_deciles, df_stats_quintiles, df_stats_quartiles)

df_stats_long <- df_stats_all %>%
  pivot_longer(
    cols = matches("^pct_above"),
    names_to = "indicator",
    values_to = "value"
  ) %>%
  mutate(
    indicator_label = recode(indicator,
      "pct_above_50_noise" = "Bruit > 50 dB",
      "pct_above_60_noise" = "Bruit > 60 dB",
      "pct_above_15_no2"  = "NO2 > 15",
      "pct_above_20_no2"  = "NO2 > 20",
      "pct_above_50_ndvi" = "Limited green access (NDVI < 0.5)",
      "pct_above_60_ndvi" = "Limited green access (NDVI < 0.6)"
    )
  ) %>% 
  left_join(cities_translation)

df_stats_long <- df_stats_long %>%
  mutate(
    indicator_family = case_when(
      grepl("noise", indicator) ~ "Bruit",
      grepl("no2", indicator) ~ "NO2",
      grepl("ndvi", indicator) ~ "NDVI"
    )
  )

```

Colors

```{r}

df_stats_long <- df_stats_long %>%
  mutate(
    indicator_label = recode(indicator,
      "pct_above_50_noise" = "Exposed to noise >50 dB",
      "pct_above_60_noise" = "Exposed to noise >60 dB",
      "pct_above_15_no2"   = "Exposed to NO₂ >15 μg/m³",
      "pct_above_20_no2"   = "Exposed to NO₂ >20 μg/m³",
      "pct_above_50_ndvi"  = "Limited green access (NDVI < 0.5)",
      "pct_above_60_ndvi"  = "Limited green access (NDVI < 0.6)"
    )
  )
```

## Visualise

```{r}

df_minimal <- df_stats_long %>%
  filter(
    indicator_label %in% c(
      "Exposed to noise >50 dB",
      "Exposed to NO₂ >20 μg/m³",
      "Limited green access (NDVI < 0.5)"
    )
  )
table(df_minimal$indicator_label)

```

## Batch chart svg export

```{r}

output_dir <- "data_output/city_charts_minimal_svg/"
dir_create(output_dir)

unique_codes <- unique(df_minimal$bfs_nummer)

plot_city <- function(city_code) {
  df_city <- df_minimal %>% filter(bfs_nummer == city_code)
  ggplot(
    df_city,
    aes(
      y = factor(group),
      x = value,
      fill = indicator_label
    )
  ) +
    geom_col(
      width = 0.7,
      position = position_dodge(width = 0.8)
    ) +
    geom_text(
      aes(label = sprintf("%.1f", value), colour = indicator_label),
      position = position_dodge(width = 0.8),
      hjust = -0.15,
      size = 3.2,
      family = "IBM Plex Sans"
    ) +
    scale_fill_manual(
      values = c(
        "Exposed to noise >50 dB"           = "#FC9272",  # orange
        "Exposed to NO₂ >20 μg/m³"          = "#4882A1",  # bleu
        "Limited green access (NDVI < 0.5)" = "#A1D99B"   # vert
      )
    ) +
    scale_colour_manual(
      values = c(
        "Exposed to noise >50 dB"           = "#FC9272",
        "Exposed to NO₂ >20 μg/m³"          = "#4882A1",
        "Limited green access (NDVI < 0.5)" = "#A1D99B"
      )
    ) +
    facet_grid(quantile_type ~ indicator_family, switch = "y") +
    labs(
      title = paste("Environmental exposures –", unique(df_city$name_en)),
      y = "Group (local SES quartile/quintile/decile)",
      x = "Share of exposed households (%)",
      fill = NULL
    ) +
    theme_minimal(base_family = "IBM Plex Sans") +
    theme(
      strip.text = element_text(face = "bold"),
      axis.title.y = element_text(face = "bold"),
      axis.title.x = element_text(face = "bold"),
      legend.position = "bottom"
    ) +
    coord_cartesian(xlim = c(0, max(df_city$value, na.rm = TRUE) * 1.15))
}

walk(unique_codes, ~{
  g <- plot_city(.x)
  ggsave(
    filename = path(output_dir, paste0("city_", .x, ".svg")),
    plot = g,
    width = 8, height = 5
  )
  invisible(NULL)
})

```

## DW lollipop chart to show disparities within the cities

<https://app.datawrapper.de/edit/iLHkd/visualize#refine>

```{r}
dw_cities_lolipop <- df_stats_long %>% 
  filter(
    quantile_type == "Quartiles",
    group %in% c(1, 4),
    indicator_label %in% c(
      "Exposed to noise >50 dB",
      "Exposed to NO₂ >15 μg/m³",
      "Limited green access (NDVI < 0.5)"
    )
  ) %>% 
  select(bfs_nummer, name_en, group, indicator_label, value) %>% 
  mutate(
    indicator_label_en = case_when(
      indicator_label == "Exposed to noise >50 dB" ~ "Households exposed to noise >50 dB",
      indicator_label == "Exposed to NO₂ >15 μg/m³" ~ "Households exposed to NO₂ >15 μg/m³",
      indicator_label == "Limited green access (NDVI < 0.5)" ~ 'Households with limited green access: less than 50% of "green" surfaces within 200m'
    )
  ) %>% 
  pivot_wider(
    names_from = "group",
    values_from = "value"
  ) %>% 
  mutate(
    difference = `1` - `4`
  ) %>% 
  rename(
    "Lowest SES" = `1`,
    "Highest SES" = `4`
  )

```

```{r}

dw_cities_lolipop %>% 
  dw_data_to_chart("iLHkd")
```

# Scatterplot charts

### Classification in quartles (string)

```{r}

sf_grouped <- bind_rows(list_sf_by_commune_grouped)

sf_grouped <- sf_grouped %>%
  mutate(
    # Paires SES avec chaque variable
    ssep_noise_pair = paste0("SES", ssep3d_local_4, "-Noise", noise_4),
    ssep_no2_pair   = paste0("SES", ssep3d_local_4, "-NO2", no2_4),
    ssep_ndvi_pair  = paste0("SES", ssep3d_local_4, "-Green", ndvi_200m_4),
    
    # Labels explicites avec inversion corrigée : 1 = Low SES, 4 = High SES
    ssep_noise_label = case_when(
      ssep3d_local_4 == 1 & noise_4 == 4 ~ "Low SES / High Noise",
      ssep3d_local_4 == 1 & noise_4 == 1 ~ "Low SES / Low Noise",
      ssep3d_local_4 == 4 & noise_4 == 4 ~ "High SES / High Noise",
      ssep3d_local_4 == 4 & noise_4 == 1 ~ "High SES / Low Noise",
      TRUE ~ "Other combination"
    ),
    ssep_no2_label = case_when(
      ssep3d_local_4 == 1 & no2_4 == 4 ~ "Low SES / High NO₂",
      ssep3d_local_4 == 1 & no2_4 == 1 ~ "Low SES / Low NO₂",
      ssep3d_local_4 == 4 & no2_4 == 4 ~ "High SES / High NO₂",
      ssep3d_local_4 == 4 & no2_4 == 1 ~ "High SES / Low NO₂",
      TRUE ~ "Other combination"
    ),
    ssep_ndvi_label = case_when(
      ssep3d_local_4 == 1 & ndvi_200m_4 == 4 ~ "Low SES / Low Green",
      ssep3d_local_4 == 1 & ndvi_200m_4 == 1 ~ "Low SES / High Green",
      ssep3d_local_4 == 4 & ndvi_200m_4 == 4 ~ "High SES / Low Green",
      ssep3d_local_4 == 4 & ndvi_200m_4 == 1 ~ "High SES / High Green",
      TRUE ~ "Other combination"
    ),
    # Combinaison globale (corrigée)
    ssep_global_label = paste0(
      ifelse(ssep3d_local_4 == 1, "Low SES", ifelse(ssep3d_local_4 == 4, "High SES", "Mid SES")), " / ",
      ifelse(no2_4 == 1, "Low NO₂", ifelse(no2_4 == 4, "High NO₂", "Mid NO₂")), " / ",
      ifelse(noise_4 == 1, "Low Noise", ifelse(noise_4 == 4, "High Noise", "Mid Noise")), " / ",
      ifelse(ndvi_200m_4 == 1, "Low Green", ifelse(ndvi_200m_4 == 4, "High Green", "Mid Green"))
    )
  )

```

### Export

```{r}

# sf_grouped %>% 
#   write_sf("data_input/data_edit/cities_reclassified.gpkg")
```

## Making scatterplot template

#### Helper: descritptive statistics to adjust axes

```{r}

desc_stats <- function(x, na.rm = TRUE) {
  data.frame(
    min = min(x, na.rm = na.rm),
    q10 = quantile(x, 0.1, na.rm = na.rm),
    q25 = quantile(x, 0.25, na.rm = na.rm),
    median = quantile(x, 0.5, na.rm = na.rm),
    q75 = quantile(x, 0.75, na.rm = na.rm),
    q90 = quantile(x, 0.9, na.rm = na.rm),
    max = max(x, na.rm = na.rm)
  )
}

# desc_stats(sf_grouped$ndvi_200m)
# desc_stats(sf_grouped$no2)
# desc_stats(sf_grouped$noise)
```

### Template noise

<https://app.datawrapper.de/edit/fTu0m/upload>

```{r}

sf_grouped %>% 
  st_drop_geometry() %>% 
  filter(bfs_nummer == 230) %>% 
  select(ssep3, noise, ssep_noise_label) %>% 
  dw_data_to_chart("fTu0m")
```

### Template NO2

<https://app.datawrapper.de/edit/i3eIP/visualize#annotate>

```{r}

sf_grouped %>% 
  st_drop_geometry() %>% 
  filter(bfs_nummer == 230) %>% 
  select(ssep3, no2, ssep_no2_label) %>% 
  dw_data_to_chart("i3eIP")
```

### Template Green

<https://app.datawrapper.de/edit/yVzPw/visualize#annotate>

```{r}

sf_grouped %>% 
  st_drop_geometry() %>% 
  filter(bfs_nummer == 230) %>% 
  select(ssep3, ndvi_200m, ssep_ndvi_label) %>%
  mutate(ndvi_200m = ndvi_200m * 100) %>% 
  dw_data_to_chart("yVzPw")
```

## DW Scatterplot batch production

```{r}

library(dplyr)
library(purrr)
library(DatawRappr)

dw_batch_charts_by_indicator <- function(
  df,
  bfs_list,
  template_ids = list(
    noise = "fTu0m",
    no2   = "i3eIP",
    green = "yVzPw"
  ),
  folder_ids = list(
    noise = "335712",
    no2   = "335711",
    green = "335713"
  ),
  output_chart_infos = "chart_ids.RData"
) {
  indicator_vars <- list(
    noise = list(var = "noise", label = "ssep_noise_label"),
    no2   = list(var = "no2", label = "ssep_no2_label"),
    green = list(var = "ndvi_200m", label = "ssep_ndvi_label")
  )
  
  create_city_chart <- function(city_id, indicator) {
    var_info <- indicator_vars[[indicator]]
    template_id <- template_ids[[indicator]]
    folder_id <- folder_ids[[indicator]]
    
    df_city <- df %>%
      filter(bfs_nummer == city_id) %>%
      st_drop_geometry()
    city_name <- unique(df_city$name_en)
    city_name <- paste0('<span style="font-size: 0.8em;">', city_name, '</span>')
    if(length(city_name) != 1) city_name <- as.character(city_id)
    
    new_chart <- dw_copy_chart(template_id)
    new_chart_id <- new_chart[["id"]]
    
    dw_edit_chart(
      chart_id = new_chart_id,
      title = city_name,
      folderId = folder_id
    )
    
    data_to_send <- df_city %>%
      select(
        ssep3,
        value = all_of(var_info$var),
        indicator_label = all_of(var_info$label)
      )
    if (indicator == "green") {
      data_to_send <- data_to_send %>% mutate(value = value * 100)
    }
    
    dw_data_to_chart(
      data_to_send,
      chart_id = new_chart_id
    )
    
    published_chart <- dw_publish_chart(new_chart_id, return_object = TRUE)
    
    tibble(
      city_id = city_id,
      city_name = city_name,
      indicator = indicator,
      url = published_chart$publicUrl,
      iframe = published_chart$iframeCode,
      chart_id = new_chart_id
    )
  }
  
  chart_infos <- purrr::cross_df(list(
    city_id = bfs_list,
    indicator = names(template_ids)
  )) %>%
    pmap_dfr(~create_city_chart(..1, ..2))
  
  saveRDS(chart_infos, output_chart_infos)
  chart_infos
}

```

```{r}

bfs_list <- sf_grouped %>% 
  st_drop_geometry() %>% 
  pull(bfs_nummer) %>% 
  unique()

chart_results <- dw_batch_charts_by_indicator(
  df = sf_grouped,
  bfs_list = bfs_list,
  output_chart_infos = "data_output/scatterplot_chart_ids.RData"
)

```

```{r}

# chart_results %>% filter(city_id %in% list_cities_6) %>% select(city_id, iframe) %>% clipr::write_clip()
```

### HTML Small multiple panel creation

```{r}

library(tidyr)
library(dplyr)
library(glue)

chart_results_wide <- chart_results %>%
  select(city_name, indicator, iframe) %>%
  pivot_wider(names_from = indicator, values_from = iframe)

html_blocks <- chart_results_wide %>%
  mutate(
    html = glue::glue(
      '
<div class="city-grid">
  <div class="city-title">{city_name}</div>
  <div>
    <div class="indicator-label">Noise</div>
    {noise}
  </div>
  <div>
    <div class="indicator-label">NO₂</div>
    {no2}
  </div>
  <div>
    <div class="indicator-label">Green</div>
    {green}
  </div>
</div>
      '
    )
  ) %>% pull(html)

cat(paste(html_blocks, collapse = "\n\n"))


```

# Cartography cities (6 cities)

```{r}

sf_for_maps <- sf_grouped %>% 
  filter(bfs_nummer %in% list_cities_6) %>% 
  select(name_en, ssep_noise_label, ssep_no2_label, ssep_ndvi_label, ssep_global_label)
```

### Colors

```{r}

get_cat_color <- function(label, rouge, orange) {
  case_when(
    label == rouge  ~ "#E74C3C",  # Rouge
    label == orange ~ "#FFA500",  # Orange
    TRUE            ~ "#D3D3D3"   # Gris
  )
}

sf_for_maps <- sf_grouped %>%
  select(name_en, ssep_noise_label, ssep_no2_label, ssep_ndvi_label, ssep_global_label) %>%
  mutate(
    color_noise = get_cat_color(ssep_noise_label,  "Low SES / High Noise",  "High SES / Low Noise"),
    color_no2   = get_cat_color(ssep_no2_label,    "Low SES / High NO₂",    "High SES / Low NO₂"),
    color_ndvi  = get_cat_color(ssep_ndvi_label,   "Low SES / Low Green",   "High SES / High Green")
  )

```

### Transform data to facetting

```{r}

library(tidyr)
sf_for_maps_long <- sf_for_maps %>%
  pivot_longer(
    cols = starts_with("ssep_"),
    names_to = "indicator",
    values_to = "label"
  ) %>%
  pivot_longer(
    cols = starts_with("color_"),
    names_to = "indicator_color",
    values_to = "color"
  ) %>%
  # On garde les bonnes paires label/couleur/indicateur
  filter(
    case_when(
      indicator == "ssep_noise_label"  & indicator_color == "color_noise"  ~ TRUE,
      indicator == "ssep_no2_label"    & indicator_color == "color_no2"    ~ TRUE,
      indicator == "ssep_ndvi_label"   & indicator_color == "color_ndvi"   ~ TRUE,
      TRUE ~ FALSE
    )
  ) %>%
  mutate(
    indicator = recode(indicator,
      "ssep_noise_label" = "Noise",
      "ssep_no2_label" = "NO₂",
      "ssep_ndvi_label" = "Green"
    )
  )

```

### Test map for Lausanne

```{r}
tmap_mode(mode = "view")
tm_shape(sf_for_maps_long %>% filter(name_en == "Lausanne")) +
  tm_dots(fill = "color", size = 0.4, fill.legend = tm_legend_hide()) +
  tm_facets_grid(rows = "indicator") +
  tm_title("Lausanne – Extreme SES / Exposure by Indicator")

```

### Maps for 6 cities

```{r}

list_6_cities_en_names <- unique(sf_for_maps_long$name_en)

plots <- purrr::map(
  list_6_cities_en_names,
  ~ tm_shape(sf_for_maps_long %>% filter(name_en == .x)) +
      tm_dots(fill = "color", size = 0.3, fill.legend = tm_legend_hide()) +
      tm_facets_grid(rows = "indicator") +
      tm_title(.x)
)

```

### Plot one map

```{r}
plots[[5]]   # Affiche la 1ère ville

```

### Save tmaps facets into (fucking useless) PNG

```{r}

purrr::walk2(
  plots,
  list_6_cities_en_names,
  ~ tmap_save(.x, paste0("data_output/tmaps/tmap_", .y, ".png"), width = 4000, height = 4000)
)


```

# Heatmaps geometry with Claude

```{r}

min_households_per_hotspot = 5

# Workflow propre pour créer des hotspots anonymisés
library(dplyr)
library(sf)

# 1. CRÉER LES HOTSPOTS AVEC COMPTAGE INTÉGRÉ
create_hotspots_with_counts <- function(sf_data, 
                                       target_indicator = "Green",
                                       sigma = 50,
                                       quantile_cut = 0.85,
                                       min_points = 8,
                                       min_households_per_hotspot = 5) {
  
  # Définir les catégories d'intérêt
  if (target_indicator == "Green") {
    wealthy_healthy <- "High SES / High Green"
    poor_unhealthy <- "Low SES / Low Green"
  } else if (target_indicator == "Noise") {
    wealthy_healthy <- "High SES / Low Noise"
    poor_unhealthy <- "Low SES / High Noise"
  } else if (target_indicator == "NO₂") {
    wealthy_healthy <- "High SES / Low NO₂"
    poor_unhealthy <- "Low SES / High NO₂"
  }
  
  # Filtrer les données pour l'indicateur
  sf_filtered <- sf_data %>%
    filter(indicator == target_indicator,
           label %in% c(wealthy_healthy, poor_unhealthy))
  
  cities <- unique(sf_filtered$name_en)
  
  # Fonction pour créer des polygones avec comptage
  create_counted_polygons <- function(points_sf, category_name) {
    if (nrow(points_sf) < min_points) return(NULL)
    
    original_crs <- st_crs(points_sf)
    
    # Projeter en LV95 pour les calculs
    if (st_is_longlat(points_sf)) {
      points_projected <- st_transform(points_sf, 2056)
    } else {
      points_projected <- points_sf
    }
    
    coords <- st_coordinates(points_projected)
    bbox <- st_bbox(points_projected)
    margin <- sigma * 2
    
    w <- owin(xrange = c(bbox$xmin - margin, bbox$xmax + margin),
              yrange = c(bbox$ymin - margin, bbox$ymax + margin))
    
    ppp_pts <- ppp(x = coords[,1], y = coords[,2], window = w)
    dens <- density.ppp(ppp_pts, sigma = sigma, edge = TRUE)
    
    ras <- raster::raster(dens)
    raster::crs(ras) <- sp::CRS("+init=epsg:2056")
    stars_ras <- st_as_stars(ras)
    
    vals <- as.vector(stars_ras[[1]])
    vals_clean <- vals[!is.na(vals) & vals > 0]
    
    if (length(vals_clean) == 0) return(NULL)
    
    threshold <- quantile(vals_clean, probs = quantile_cut, na.rm = TRUE)
    contours <- st_contour(stars_ras, breaks = threshold)
    
    if (nrow(contours) == 0) return(NULL)
    
    # Créer un masque avec les points
    points_buffer <- st_buffer(points_projected, dist = sigma * 1.5)
    points_union <- st_union(points_buffer)
    
    # Traitement des polygones individuels (PAS de dissolve)
    polygons <- contours %>%
      filter(Max == Inf | Max > threshold) %>%
      st_cast("POLYGON") %>%
      st_buffer(0) %>%
      st_intersection(points_union) %>%
      st_simplify(dTolerance = 10) %>%
      mutate(
        area_m2 = as.numeric(st_area(.)),
        # COMPTAGE DES MÉNAGES PAR POLYGONE
        n_households = lengths(st_intersects(., points_projected))
      ) %>%
      # FILTRAGE PAR SEUIL D'ANONYMISATION
      filter(
        area_m2 > 1000,
        n_households >= min_households_per_hotspot
      ) %>%
      select(-any_of(c("layer", "Min", "Max"))) %>%
      mutate(
        city = unique(points_sf$name_en)[1],
        category = category_name,
        indicator = target_indicator,
        n_source_points = nrow(points_sf),
        hotspot_id = paste0(target_indicator, "_", category_name, "_", 
                           unique(points_sf$name_en)[1], "_", row_number())
      )
    
    # Retransformer dans le CRS original
    if (!is.na(original_crs)) {
      polygons <- st_transform(polygons, original_crs)
    }
    
    return(polygons)
  }
  
  # Traiter chaque ville et chaque catégorie
  results <- map_dfr(cities, function(city) {
    city_data <- sf_filtered %>% filter(name_en == city)
    
    wealthy_points <- city_data %>% filter(label == wealthy_healthy)
    poor_points <- city_data %>% filter(label == poor_unhealthy)
    
    wealthy_polygons <- create_counted_polygons(wealthy_points, "wealthy_healthy")
    poor_polygons <- create_counted_polygons(poor_points, "poor_unhealthy")
    
    bind_rows(wealthy_polygons, poor_polygons)
  })
  
  cat("=== RÉSULTATS", target_indicator, "===\n")
  cat("Polygones créés:", nrow(results), "\n")
  if(nrow(results) > 0) {
    cat("Ménages par hotspot - min:", min(results$n_households), 
        "max:", max(results$n_households), "\n")
    cat("Distribution par ville et catégorie:\n")
    print(table(results$city, results$category))
  }
  cat("\n")
  
  return(results)
}

# 2. CRÉER LES 3 INDICATEURS AVEC ANONYMISATION
hotspots_green_clean <- create_hotspots_with_counts(
  sf_for_maps_long,
  target_indicator = "Green",
  sigma = 50,
  quantile_cut = 0.9,
  min_points = 10,
  min_households_per_hotspot = min_households_per_hotspot
)

hotspots_noise_clean <- create_hotspots_with_counts(
  sf_for_maps_long,
  target_indicator = "Noise",
  sigma = 50,
  quantile_cut = 0.9,
  min_points = 10,
  min_households_per_hotspot = min_households_per_hotspot
)

hotspots_no2_clean <- create_hotspots_with_counts(
  sf_for_maps_long,
  target_indicator = "NO₂",
  sigma = 50,
  quantile_cut = 0.9,
  min_points = 10,
  min_households_per_hotspot = min_households_per_hotspot
)

# 3. EXPORT DIRECT EN GEOJSON POUR MAPBOX
output_dir <- "data_output/mapbox"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# Transformer en WGS84 et exporter directement
export_for_mapbox <- function(hotspots_sf, filename) {
  if(nrow(hotspots_sf) > 0) {
    hotspots_wgs84 <- st_transform(hotspots_sf, 4326)
    st_write(hotspots_wgs84, 
             file.path(output_dir, filename), 
             delete_dsn = TRUE)
    cat("✅", filename, ":", nrow(hotspots_wgs84), "polygones exportés\n")
  } else {
    cat("❌", filename, ": aucun polygone à exporter\n")
  }
}

export_for_mapbox(hotspots_green_clean, "hotspots_green_anonymised.geojson")
export_for_mapbox(hotspots_noise_clean, "hotspots_noise_anonymised.geojson")
export_for_mapbox(hotspots_no2_clean, "hotspots_no2_anonymised.geojson")

# 4. RÉSUMÉ FINAL
total_polygons <- nrow(hotspots_green_clean) + nrow(hotspots_noise_clean) + nrow(hotspots_no2_clean)
cat("\n🎯 RÉSUMÉ FINAL\n")
cat("Total hotspots anonymisés:", total_polygons, "\n")
cat("Seuil d'anonymisation: minimum 10 ménages par hotspot\n")
cat("Fichiers prêts pour Mapbox dans:", output_dir, "\n")
```

### 

# Inequalities (SSEP "pure")

## National

```{r}

ses_national_inequality <- sf_grouped %>%
  st_drop_geometry() %>%
  summarise(
      # Déciles 10 et 90

    d10 = quantile(ssep3, 0.1),
    d25 = quantile(ssep3, 0.25),
    d50 = quantile(ssep3, 0.5),
    d75 = quantile(ssep3, 0.75),
    d90 = quantile(ssep3, 0.9),
    .groups = "drop"
  ) %>% mutate(
    name_en = '<span style="font-weight: bold;">Switzerland</span>'
  ) %>% select(
    name_en, everything()
  )
```

## Cities

```{r}

# Indicateurs d'inégalité SES par ville
ses_inequality <- sf_grouped %>%
  st_drop_geometry() %>%
  group_by(name_en) %>%
  summarise(
      # Déciles 10 et 90

    d10 = quantile(ssep3, 0.1),
    d25 = quantile(ssep3, 0.25),
    d50 = quantile(ssep3, 0.5),
    d75 = quantile(ssep3, 0.75),
    d90 = quantile(ssep3, 0.9),
    
    
    # Écart interdécile
    p90_p10_ratio = quantile(ssep3, 0.9) / quantile(ssep3, 0.1),
    p90_p10_diff = quantile(ssep3, 0.9) - quantile(ssep3, 0.1),
    
    # Coefficient de variation
    cv_ssep = sd(ssep3) / mean(ssep3),
    
    # Gini (avec package ineq)
    gini_ssep = ineq::Gini(ssep3),
    
    # Range
    ssep_range = max(ssep3) - min(ssep3),
    
    .groups = "drop"
  ) %>%
  arrange(desc(p90_p10_diff))

# Visualisation
ses_inequality %>%
  ggplot(aes(x = reorder(name_en, p90_p10_diff), y = p90_p10_diff)) +
  geom_col(fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  labs(
    title = "Ampleur des inégalités socio-économiques par ville",
    subtitle = "Différence entre 90e et 10e percentile du SES",
    x = "Ville", y = "Écart SES (90e - 10e percentile)"
  )
```

```{r}

# Classement des villes par inégalité SES
ses_inequality %>%
  select(name_en, gini_ssep, p90_p10_diff) %>%
  arrange(desc(gini_ssep)) %>%
  mutate(
    gini_pct = round(gini_ssep * 100, 1),
    rang = row_number()
  )
```

```{r}
# Gini avec interprétation
ses_inequality %>%
  ggplot(aes(x = reorder(name_en, gini_ssep), y = gini_ssep)) +
  geom_col(aes(fill = gini_ssep), alpha = 0.8) +
  scale_fill_gradient(low = "lightblue", high = "darkred") +
  coord_flip() +
  labs(
    title = "Intensité des inégalités socio-économiques",
    subtitle = "Indice de Gini du statut socio-économique par ville",
    x = "Ville", 
    y = "Indice de Gini (0 = égalité parfaite, 1 = inégalité maximale)"
  )
```

### DW SSEP3 - chart

<https://app.datawrapper.de/edit/3xp9e/upload>

```{r}
library(DatawRappr)
ses_inequality %>% 
  select(name_en:d90) %>% 
  rbind(ses_national_inequality) %>%
  dw_data_to_chart("3xp9e")
```
