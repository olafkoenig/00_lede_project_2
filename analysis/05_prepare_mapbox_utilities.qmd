---
title: "05_prepare_mapbox_utilities"
author: "Olaf K√∂nig"
format: html
editor: visual
---

# Mapbox utilities and web assets preparation

## Objective
Prepare all auxiliary geographic data needed for the web map integration: anonymized SES hexagons, clean municipal boundaries, city centroids, and optionally classified raster tiles.

## Source data
- `data_input/data_edit/cities_reclassified.gpkg` - Cities with SES classifications
- `data_input/data_raw/sf_polg_swisstopo.gpkg` - Municipal boundaries
- `data_input/data_raw/swisstopo_tlm_lakes.gpkg` - Lakes for boundary cleaning
- `data_input/data_raw/stats_cities.csv` - City population data

## Processing steps
1. **SES hexagon aggregation** : Create anonymized hexagonal grids showing dominant SES patterns
2. **Municipal boundaries** : Clean city limits by removing lake areas
3. **City centroids** : Calculate center points for map navigation and labeling
4. **Situation map data** : Prepare responsive markers for overview map

## Final outputs
- `data_output/mapbox/sep_hex.geojson` - Anonymized SES hexagons
- `data_output/mapbox/cities.geojson` - Clean municipal boundaries
- `data_output/city_centroids_mapbox.csv` - City center coordinates
- `data_output/mapbox_vectors/*.geojson` - Classified environmental layers (noise, NO‚ÇÇ, NDVI)

---

```{r setup}
library(tidyverse)
library(sf)
```

```{r load-data}
# Load main datasets
sf <- read_sf("data_input/data_edit/cities_reclassified.gpkg") %>% 
  select(id, bfs_nummer, ssep3d_local_4)

sf_municipalities <- read_sf("data_input/data_raw/sf_polg_swisstopo.gpkg")
sf_lakes <- read_sf("data_input/data_raw/swisstopo_tlm_lakes.gpkg") %>% 
  filter(surface_km2 >= 1)

df_cities_pop <- read_csv("data_input/data_raw/stats_cities.csv") %>% 
  select(bfs_nummer, nom_officiel, POP_2023)

# Define city lists
list_cities_10 <- df_cities_pop %>% 
  slice_max(POP_2023, n = 10) %>% 
  pull(bfs_nummer)

list_cities_6 <- df_cities_pop %>% 
  slice_max(POP_2023, n = 6) %>% 
  pull(bfs_nummer)

sf_cities_10 <- sf_municipalities %>% 
  filter(bfs_nummer %in% list_cities_10)
```

# 1. SES hexagon aggregation for anonymization

## 1.1 Hexagon creation functions

```{r}
# Create hexagonal aggregation for one city
create_hex_city <- function(sf_city, hex_size = 100, min_points = 5) {
  
  city_code <- unique(sf_city$bfs_nummer)
  
  # Create hexagonal grid for this city
  hex_grid <- st_make_grid(
    sf_city, 
    cellsize = hex_size, 
    square = FALSE
  ) %>% 
    st_sf() %>% 
    mutate(hex_id = paste0(city_code, "_", row_number()))
  
  # Join points to hexagons
  sf_with_hex <- st_join(sf_city, hex_grid)
  
  # Calculate stats per hexagon
  hex_stats <- sf_with_hex %>% 
    st_drop_geometry() %>% 
    filter(!is.na(hex_id)) %>%
    group_by(hex_id, bfs_nummer) %>% 
    summarise(
      n_points = n(),
      pct_q1 = sum(ssep3d_local_4 == 1) / n() * 100,
      pct_q2 = sum(ssep3d_local_4 == 2) / n() * 100, 
      pct_q3 = sum(ssep3d_local_4 == 3) / n() * 100,
      pct_q4 = sum(ssep3d_local_4 == 4) / n() * 100,
      dominant_class = as.numeric(names(sort(table(ssep3d_local_4), decreasing = TRUE))[1]),
      dominant_pct = max(pct_q1, pct_q2, pct_q3, pct_q4),
      .groups = "drop"
    ) %>% 
    filter(n_points >= min_points) %>%
    mutate(
      dominance_type = case_when(
        dominant_pct >= 60 ~ paste0("Dominant Q", dominant_class),
        dominant_pct >= 40 ~ paste0("Mixed (Q", dominant_class, " majority)"),
        TRUE ~ "Highly mixed"
      )
    )
  
  # Final geometry with stats
  hex_final <- hex_grid %>% 
    inner_join(hex_stats, by = "hex_id")
  
  return(hex_final)
}

# Main aggregation function
create_hex_aggregation <- function(sf_data, hex_size = 100, min_points = 5) {
  
  # Split by city
  sf_by_city <- split(sf_data, sf_data$bfs_nummer)
  
  # Process each city
  hex_list <- map(sf_by_city, ~create_hex_city(.x, hex_size, min_points))
  
  # Combine results
  hex_combined <- bind_rows(hex_list)
  
  return(hex_combined)
}
```

## 1.2 Create and export SES hexagons

```{r}
cat("üî∂ Creating anonymized SES hexagons...\n")

# Create hexagonal aggregation
sf_hex <- create_hex_aggregation(sf, hex_size = 100, min_points = 5)

# Summary statistics
cat("Hexagons created:", nrow(sf_hex), "\n")
sf_hex %>% 
  st_drop_geometry() %>% 
  count(dominance_type, sort = TRUE) %>%
  print()

# Export for web (top 3 cities only for demo)
sf_hex_mapbox <- sf_hex %>% 
  filter(bfs_nummer %in% c(3203, 5586, 6621)) %>%  # St. Gallen, Lausanne, Geneva
  select(bfs_nummer, n_points, dominant_class) %>% 
  st_transform(4326)

# Create output directory
dir.create("data_output/mapbox", showWarnings = FALSE, recursive = TRUE)

# Export
st_write(sf_hex_mapbox, "data_output/mapbox/sep_hex.geojson", delete_dsn = TRUE, quiet = TRUE)

cat("‚úÖ SES hexagons exported to data_output/mapbox/sep_hex.geojson\n")
cat("   Cities included:", length(unique(sf_hex_mapbox$bfs_nummer)), "\n")
cat("   Total hexagons:", nrow(sf_hex_mapbox), "\n\n")
```

# 2. Municipal boundaries without lakes

## 2.1 Clean city boundaries

```{r}
cat("üó∫Ô∏è Creating clean municipal boundaries...\n")

# Remove lakes from municipal boundaries
sf_cities_10_clean <- st_difference(sf_cities_10, st_union(sf_lakes))

# Transform to WGS84 and export
sf_cities_10_clean %>% 
  select(bfs_nummer, name) %>% 
  st_transform(4326) %>% 
  write_sf("data_output/mapbox/cities.geojson", delete_dsn = TRUE, quiet = TRUE)

cat("‚úÖ Clean city boundaries exported to data_output/mapbox/cities.geojson\n")
cat("   Cities included:", nrow(sf_cities_10_clean), "\n")
cat("   Lakes removed from boundaries\n\n")
```

# 3. City centroids for map navigation

## 3.1 Calculate centroids and add metadata

```{r}
cat("üìç Calculating city centroids...\n")

# English translations
cities_translation <- tibble(
  bfs_nummer = c(261, 6621, 2701, 5586, 351, 230, 1061, 3203, 5192, 371),
  name_en = c(
    "Zurich", "Geneva", "Basel", "Lausanne", "Bern",
    "Winterthur", "Lucerne", "St. Gallen", "Lugano", "Biel/Bienne"
  )
)

# Calculate centroids (after lake removal)
city_centroids <- sf_cities_10_clean %>%
  st_transform(4326) %>%  # WGS84 for web
  st_centroid() %>%
  mutate(
    longitude = st_coordinates(.)[,1],
    latitude = st_coordinates(.)[,2]
  ) %>%
  st_drop_geometry() %>%
  select(bfs_nummer, name, longitude, latitude) %>%
  left_join(cities_translation, by = "bfs_nummer") %>%
  left_join(df_cities_pop, by = "bfs_nummer")

# Display results
print(city_centroids)

# Export for general use
write_csv(city_centroids, "data_output/city_centroids_mapbox.csv")

cat("‚úÖ City centroids exported to data_output/city_centroids_mapbox.csv\n\n")
```

# 4. Raster classification and vectorization

## 4.1 Load rasters

```{r}
library(terra)

# Load environmental rasters
rast_noise <- rast("data_input/data_raw/LrStrasseTag_4_0_Meter.tif")

rast_no2 <- rast("data_input/data_raw/no2_ymw_2021.asc") %>%
  {crs(.) <- "EPSG:21781"; .} %>%  # Assign LV03 CRS
  project("EPSG:2056")              # Reproject to LV95

rast_ndvi <- rast("/Users/bajj@mediait.ch/Documents/Tamedia/2025/2025-05_Vegetation_Index/data_output/tile_fusion/composite_terra_ordered.tif") %>% 
  project("EPSG:2056")

cat("üìä Rasters loaded:\n")
cat("   Noise: CRS", crs(rast_noise, describe = TRUE)$name, "\n")
cat("   NO‚ÇÇ: CRS", crs(rast_no2, describe = TRUE)$name, "\n") 
cat("   NDVI: CRS", crs(rast_ndvi, describe = TRUE)$name, "\n\n")
```

## 4.2 Classification thresholds

```{r}
# Noise: 10dB increments from 0 to 70+
seuils_noise <- c(0, seq(10, 70, 10), Inf)
labels_noise <- c("0-10", "10-20", "20-30", "30-40", "40-50", "50-60", "60-70", "70+")

# NO‚ÇÇ: 5 Œºg/m¬≥ increments from 0 to 40+
seuils_no2 <- c(0, seq(5, 40, 5), Inf)
labels_no2 <- c("0-5", "5-10", "10-15", "15-20", "20-25", "25-30", "30-35", "35-40", "40+")

# NDVI: special class for <0.2, then 0.1 increments from 0.2 to 1.0+
seuils_ndvi <- c(-Inf, 0.2, seq(0.3, 1.0, 0.1), Inf)
labels_ndvi <- c("<0.2", "0.2-0.3", "0.3-0.4", "0.4-0.5", "0.5-0.6", 
                 "0.6-0.7", "0.7-0.8", "0.8-0.9", "0.9-1.0", "1.0+")

cat("üìã Classification thresholds defined:\n")
cat("   Noise:", length(labels_noise), "classes\n")
cat("   NO‚ÇÇ:", length(labels_no2), "classes\n")
cat("   NDVI:", length(labels_ndvi), "classes\n\n")
```

## 4.3 Vectorization function

```{r}
vectoriser_raster_ville <- function(raster, sf_ville, seuils, labels, nom_raster, sf_lakes) {
  ville_nom <- if("nom_officiel" %in% names(sf_ville)) sf_ville$nom_officiel else as.character(sf_ville$bfs_nummer)
  cat("  Processing city:", ville_nom, "\n")
  
  # Project city to raster CRS
  sf_ville_proj <- st_transform(sf_ville, crs(raster))
  
  # 200m buffer for context
  sf_ville_buffer <- st_buffer(sf_ville_proj, 200)
  
  # Convert to SpatVector for terra
  ville_vect <- vect(sf_ville_buffer)
  
  # Crop and mask raster
  raster_clip <- crop(raster, ville_vect)
  raster_mask <- mask(raster_clip, ville_vect)
  
  # Classification matrix
  rcl_matrix <- matrix(c(seuils[-length(seuils)], seuils[-1], 1:length(labels)), ncol = 3)
  
  # Classify
  raster_class <- classify(raster_mask, rcl_matrix, include.lowest = TRUE)
  
  # Vectorize
  vect_polygons <- as.polygons(raster_class, dissolve = TRUE)
  sf_polygons <- st_as_sf(vect_polygons)
  
  # Check for data
  if (nrow(sf_polygons) == 0) {
    cat("    No data found\n")
    return(NULL)
  }
  
  # Get value column
  col_valeurs <- names(sf_polygons)[1]
  
  # Create final attributes
  sf_final <- sf_polygons %>%
    mutate(
      raster_source = nom_raster,
      city = ville_nom,
      bfs_nummer = sf_ville$bfs_nummer,
      class_ord = .data[[col_valeurs]], # Ordinal value 1 to n
      class_range = case_when(
        class_ord >= 1 & class_ord <= length(labels) ~ labels[class_ord],
        TRUE ~ "Unclassified"
      ),
      .before = 1
    ) %>%
    select(-all_of(col_valeurs)) %>%
    filter(class_ord >= 1 & class_ord <= length(labels)) # Keep only valid classes
  
  # Remove lakes (faster at the end)
  if (!is.null(sf_lakes) && nrow(sf_final) > 0) {
    sf_lakes_proj <- st_transform(sf_lakes, st_crs(sf_final))
    if (nrow(sf_lakes_proj) > 0) {
      sf_final <- st_difference(sf_final, st_union(sf_lakes_proj))
    }
  }
  
  # Transform to WGS84 for web
  sf_wgs84 <- st_transform(sf_final, "EPSG:4326")
  
  cat("    ", nrow(sf_wgs84), "polygons created\n")
  return(sf_wgs84)
}
```

## 4.4 Process all indicators by city

```{r}
# Create output directory
dir.create("data_output/mapbox_vectors", showWarnings = FALSE, recursive = TRUE)

cat("üîÑ Processing raster vectorization...\n")

# Process each indicator for each city
for (i in 1:nrow(sf_cities_10)) {
  sf_ville <- sf_cities_10[i, ]
  ville_nom_clean <- gsub("[^A-Za-z0-9]", "", sf_ville$name)
  
  cat("\n--- Processing", sf_ville$name, "---\n")
  
  # NOISE
  sf_noise <- vectoriser_raster_ville(rast_noise, sf_ville, seuils_noise, labels_noise, "noise", sf_lakes)
  if (!is.null(sf_noise) && nrow(sf_noise) > 0) {
    filename <- paste0("data_output/mapbox_vectors/noise_", sf_ville$bfs_nummer, "_", ville_nom_clean, ".geojson")
    st_write(sf_noise, filename, delete_dsn = TRUE, quiet = TRUE)
    size_kb <- round(file.size(filename) / 1024, 1)
    cat("    ‚úÖ Noise:", basename(filename), "(", size_kb, "KB)\n")
  }
  
  # NO‚ÇÇ
  sf_no2 <- vectoriser_raster_ville(rast_no2, sf_ville, seuils_no2, labels_no2, "no2", sf_lakes)
  if (!is.null(sf_no2) && nrow(sf_no2) > 0) {
    filename <- paste0("data_output/mapbox_vectors/no2_", sf_ville$bfs_nummer, "_", ville_nom_clean, ".geojson")
    st_write(sf_no2, filename, delete_dsn = TRUE, quiet = TRUE)
    size_kb <- round(file.size(filename) / 1024, 1)
    cat("    ‚úÖ NO‚ÇÇ:", basename(filename), "(", size_kb, "KB)\n")
  }
  
  # NDVI
  sf_ndvi <- vectoriser_raster_ville(rast_ndvi, sf_ville, seuils_ndvi, labels_ndvi, "ndvi", sf_lakes)
  if (!is.null(sf_ndvi) && nrow(sf_ndvi) > 0) {
    filename <- paste0("data_output/mapbox_vectors/ndvi_", sf_ville$bfs_nummer, "_", ville_nom_clean, ".geojson")
    st_write(sf_ndvi, filename, delete_dsn = TRUE, quiet = TRUE)
    size_kb <- round(file.size(filename) / 1024, 1)
    cat("    ‚úÖ NDVI:", basename(filename), "(", size_kb, "KB)\n")
  }
}

cat("\n‚úÖ All raster vectorization complete!\n\n")
```

# 5. Final summary

## 5.1 Mapbox assets summary

```{r}
cat("üéØ MAPBOX ASSETS SUMMARY\n")
cat("========================\n")

# Check all output files
hex_files <- list.files("data_output/mapbox", pattern = "sep_hex\\.geojson$", full.names = TRUE)
boundary_files <- list.files("data_output/mapbox", pattern = "cities\\.geojson$", full.names = TRUE)
vector_files <- list.files("data_output/mapbox_vectors", pattern = "\\.geojson$", full.names = TRUE)
centroid_files <- list.files("data_output", pattern = "city_centroids_mapbox\\.csv", recursive = TRUE, full.names = TRUE)

all_files <- c(hex_files, boundary_files, vector_files, centroid_files)

if (length(all_files) > 0) {
  total_size_kb <- 0
  
  cat("üì¶ CORE ASSETS:\n")
  for (file in c(hex_files, boundary_files, centroid_files)) {
    if (file.exists(file)) {
      size_kb <- round(file.size(file) / 1024, 1)
      total_size_kb <- total_size_kb + size_kb
      
      if (grepl("\\.geojson$", file)) {
        n_features <- nrow(st_read(file, quiet = TRUE))
        cat("üìÅ", basename(file), "-", size_kb, "KB -", n_features, "features\n")
      } else {
        cat("üìÅ", basename(file), "-", size_kb, "KB\n")
      }
    }
  }
  
  cat("\nüìä VECTORIZED RASTERS:\n")
  if (length(vector_files) > 0) {
    for (file in vector_files) {
      if (file.exists(file)) {
        size_kb <- round(file.size(file) / 1024, 1)
        total_size_kb <- total_size_kb + size_kb
        n_features <- nrow(st_read(file, quiet = TRUE))
        cat("üìÅ", basename(file), "-", size_kb, "KB -", n_features, "polygons\n")
      }
    }
  } else {
    cat("‚ùå No vector files found in data_output/mapbox_vectors/\n")
  }
  
  cat("\nTotal size:", round(total_size_kb / 1024, 1), "MB\n")
  cat("Total files:", length(all_files), "\n")
} else {
  cat("‚ùå No output files found\n")
}

cat("\nüåç All assets ready for web integration!\n")
```

## 5.2 Usage instructions

```{r}
cat("\nüìñ USAGE INSTRUCTIONS\n")
cat("=====================\n")
cat("1. üî∂ sep_hex.geojson - Add as Mapbox layer for SES patterns\n")
cat("2. üó∫Ô∏è cities.geojson - Use as boundary overlay\n") 
cat("3. üìç city_centroids_mapbox.csv - Use for map navigation/labeling\n")
cat("4. üìä mapbox_vectors/*.geojson - Classified environmental layers:\n")
cat("   - noise_*_*.geojson - Noise exposure levels by city\n")
cat("   - no2_*_*.geojson - Air pollution levels by city\n") 
cat("   - ndvi_*_*.geojson - Vegetation coverage by city\n")
cat("\nAll files use WGS84 (EPSG:4326) coordinate system\n")
cat("Ready for Mapbox Studio integration! üöÄ\n")
```